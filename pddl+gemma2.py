from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig
import torch
import subprocess
import os
import logging
from transformers import logging as hf_logging

hf_logging.set_verbosity_error()

nf4_config = BitsAndBytesConfig(
    load_in_4bit=True,
    bnb_4bit_quant_type="nf4",
    bnb_4bit_use_double_quant=True,
    bnb_4bit_compute_dtype=torch.bfloat16
)

model = AutoModelForCausalLM.from_pretrained("google/gemma-2-9b-it", quantization_config=nf4_config, device_map="auto")
tokenizer = AutoTokenizer.from_pretrained("google/gemma-2-9b-it")

domain_file = 'C:/Users/User/Desktop/pddlfile/domain.pddl'
problem_file = 'C:/Users/User/Desktop/pddlfile/problem.pddl'
problem2_file = 'C:/Users/User/Desktop/pddlfile/problem2.pddl'

# 語言模型生成目標
def generate_response(prompt):
    # 將 prompt 編碼為 token ID
    prompt_tokens = tokenizer.encode(prompt, return_tensors="pt").to("cuda")
    
    # 使用模型生成回應
    outputs = model.generate(
        prompt_tokens,
        max_new_tokens=200,
        pad_token_id=tokenizer.eos_token_id  # 避免過多生成
    )
    output_tokens = outputs[0].tolist()  # 轉換為 list 格式的 token IDs
    prompt_tokens_list = prompt_tokens[0].tolist()  # prompt 的 token IDs
    
    # 刪除與 prompt 相同的 token IDs
    if len(output_tokens) > len(prompt_tokens_list):
        output_tokens = output_tokens[len(prompt_tokens_list):]
    # 將保留的 token ID 解碼為文本
    response_cleaned = tokenizer.decode(output_tokens, skip_special_tokens=True).strip()
    
    return response_cleaned

# 讀取原始的 problem.pddl 並插入目標條件
def update_pddl_problem(goal_conditions):
    # 讀取 problem.pddl
    with open(problem_file, 'r') as f:
        problem_content = f.read()

    # 將語言模型生成的內容插入到 # 處
    updated_problem = problem_content.replace('#', goal_conditions)

    # 將更新後的內容寫回 problem.pddl
    with open(problem2_file, 'w') as f:
        f.write(updated_problem)

# 執行 pyperplan 任務規劃
def execute_planner():
    cmd = ['pyperplan', domain_file, problem2_file]
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        #print("日誌輸出:")
        #print(result.stdout)

        if result.stderr:
            print("錯誤訊息:")
            print(result.stderr)

        # 查看生成的解決方案檔案
        solution_file = problem2_file + '.soln'
        if os.path.exists(solution_file):
            #print(f"task plan finished，path: {solution_file}")
            with open(solution_file, 'r') as f:
                solution = f.read()
                solution = process_solution(solution)
                print("task plan(generated by pddl planner):")
                print(solution)
        else:
            print("未找到解決方案檔案。")
    except FileNotFoundError:
        print("pyperplan 未安裝或路徑未正確設定。")

def process_solution(solution):
 
    actions = solution.strip().split('\n')
    
    reordered_actions = []
    pending_installations = []  
    
    # 遍歷所有行動
    for i, action in enumerate(actions):
        if action.startswith("(insert"):
            wire_name = action.split()[2]
            
            for j in range(i + 1, len(actions)):
                if actions[j].startswith("(lock") and wire_name in actions[j]:
                    reordered_actions.append(action) 
                    reordered_actions.append(actions[j])  
                    pending_installations.append(j) 
                    break
            else:
                reordered_actions.append(action)
        elif i not in pending_installations:
            reordered_actions.append(action)
    return '\n'.join(reordered_actions)
    
if __name__ == "__main__":
    prompt_template_file = 'C:/Users/User/Desktop/pddlfile/prompt_template.txt'
    with open(prompt_template_file, 'r', encoding='utf-8') as f:
        prompt_template = f.read()
    while True:
        user_input = input("command (enter 'exit' to stop): ")
        if user_input.lower() == 'exit':
            print("end")
            break
        prompt = prompt_template.replace('#', user_input)
        goal_conditions = generate_response(prompt)
        print("goal(generated by LLM):", goal_conditions)
        update_pddl_problem(goal_conditions)
        execute_planner()